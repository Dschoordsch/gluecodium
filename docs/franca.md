Genium FIDL and FDEPL syntax
================================

Genium uses [Franca][franca] to define APIs. A full guide on the Franca IDL can be found in the
[franca user guide][userguide].

This file describes additional FIDL and FDEPL syntax used by Genium.


FIDL and FDEPL files
--------------------

Interfaces in Franca are described in .fidl files. A class MyGeneratedClass would have an
`interface MyGeneratedClass` in a `MyGeneratedClass.fidl`. Fidl files are meant to describe an
interface and its methods. Any platform-, language- or otherwise specific information that needs to
be defined should be defined in an accompanying .fdepl file. In this case it would be in a
`MyGeneratedClass.fdepl` file.

**Note:** Chapter five and six in the [user guide][userguide] describes in detail the syntax of the
.fidl and .fdepl files, something that is beyond the scope of this document.


Custom FIDL syntax
------------------

### Instance reference

Genium extends the concept of Franca interface by allowing creation of instances of those
interfaces. There is a special FIDL syntax that makes referencing such interfaces possible (e.g. as
struct field types, method parameters types, etc.).

An "instantiable" interface should have a `typedef` with the same name as the interface itself, and
the typedef should point to `undefinied` type:

    interface ExampleInstance {
        typedef ExampleInstance is undefined
    }

When referencing such interface elsewhere, the full name would be the name of the interface,
followed by a period and then the same name again:

    interface AnotherInterface {
        method doSomething {
            in {
                ExampleInstance.ExampleInstance instanceReference
            }
        }
    }

**Note:** There is no guarantee for pointer equality on Java and Swift side for the same wrapped
C++ object.

### `Date` type

Genium provides a "built-in" `Date` type in FIDL files. The following types are generated for this
"built-in" type in target languages:
* C++: `std::chrono::system_clock::time_point`
* Java: `java.util.Date`
* Swift: `Foundation.Date`

FIDL:

    package example

    import genium.Extensions.Date from "classpath:/GeniumExtensions.fidl"

    typeCollection ExampleTypes {
        struct exampleStruct {
            Date exampleField
        }
    }

### Comments

Franca supports different kinds of comments, but Genium only processes `<** @description: ... **>` tag.
The comment should be formatted in Markdown and links to other types can be added in the form `[package.Interface.method]`.

FIDL:

    <** @description:
    There is a lot to say about this interface.
    at least it has multiline comments.

    I am a heading
    --------------

    And now comes a list:
    \* asterisk
    \* needs
    \* escaping

    ```Some example code;```

    See also: [package.SomeInterface]
    **>
    interface ExampleInterface

Custom FDEPL syntax
-------------------

### Interface: IsInterface

This FDEPL property controls whether the given Franca interface is represented with a class
in generated Java/Swift code or with an interface/protocol. Default value is `false`, i.e. classes
are generated by default. This property has no effect on generated C++ headers.

When this is set to true, additional code will be generated to allow passing an interface/protocol
implemented in Java/Swift to C++ code.

**Note** It is safe to do comparison on the `std::shared_ptr` in C++ to check if it's the same
Java/Swift object as passed before.

FIDL:

    package example

    interface ExampleInterface {
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        IsInterface = true
    }

### Interface: ObjcInterface

This FDEPL property controls whether the given Franca interface is treated as an ObjC-compatible
interface, with additional infrastructure being generated in Swift code, enabling the usage of these
types and their members from Objective-C code. Default value is `false`, i.e. no additional
infrastructure is generated by default. This property affects Swift generated code only.

FIDL:

    package example

    interface ExampleInterface {
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        ObjcInterface = true
    }

### Method: Const

This FDEPL property controls whether the given Franca method is generated with a `const`
specifier in C++. Default value is `false`, i.e. no `const` specifier is generated. This property
has no effect on generated code for Java or Swift.

FIDL:

    package example

    interface ExampleInterface {
        method exampleMethod {
        }
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        method exampleMethod {
            Const = true
        }
    }

### Method, Attribute: Static

This FDEPL property controls whether the given Franca method or attribute is generated as `static`
in all supported languages. Default value is `false`, i.e. an instance method or attribute is
generated.

**Note:** Static methods are not supported if `IsInterface` property is set to `true`.

FIDL:

    package example

    interface ExampleInterface {
        method exampleMethod {
        }
        attribute String exampleAttribute
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        method exampleMethod {
            Static = true
        }
        attribute exampleAttribute {
            Static = true
        }
    }

### Method: Constructor

This FDEPL property controls whether the given Franca method is generated as a constructor in Java
and as an initializer in Swift. Default value is `false`, i.e. an instance method is generated. This
property only affects Java and Swift generated code. Methods marked as "Constructor" are just static
methods in C++ (not constructors).

**Note:** Constructors are not supported if `IsInterface` property is set to `true`.

**Note:** Method overloading generally works for constructors. One notable exception is that a pair
of constructors overloaded on an Array or Map parameter (i.e. having signatures that differ only in
array/map element types) will generate uncompilable code in Java (Swift and C++ will still compile).

**Note:** Constructors are also supported for structs (see `Companion` below).

FIDL:

    package example

    interface ExampleInterface {
        typedef ExampleInterface is undefined
        method exampleMethod {
            out {
                ExampleInterface result
            }
        }
    }

FDEPL:

    define GeniumExtensions for interface example.ExampleInterface
    {
        method exampleMethod {
            Constructor = true
        }
    }

### Struct: Serializable

This FDEPL property controls whether any serialization infrastructure is generated for the
given Franca struct. Default value is `false`, i.e. no serialization infrastructure is generated.
Currently the only serialization type supported is `android.os.Parcelable` for generated Java code.
This property currently has no effect on generated code for C++ or Swift.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Serializable = true
        }
    }

### Struct, Interface: Equatable

This FDEPL property controls whether a Franca struct or Franca interface are equal comparable.
For structs the comparison function implementation is generated, for instances only the declaration.
Default value is `false`, i.e. no equality helpers are generated. This affects C++,
Java and Swift generated code.
Types marked as `Equatable` also support hashing on Java and Swift side.

**Note:** All fields in structs marked as `Equatable` need to be of simple type or be marked as
`Equatable` or `PointerEquatable` themselves.

**Note:** Only interfaces with `IsInterface=false` are supported.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Equatable = true
        }
    }

### Interface: PointerEquatable

This FDEPL property controls whether a Franca interface is equal comparable by comparing the instances
raw pointer. Default value is `false`, i.e. no equality helpers are generated. This affects C++,
Java and Swift generated code.
Interfaces marked as `PointerEquatable` also support hashing.

**Note:** Only interfaces with `IsInterface=false` are supported.

FIDL:

    package example

    interface PointerEqualInterface {
    }

FDEPL:

    define GeniumExtensions for interface example.PointerEqualInterface
    {
        PointerEquatable = true
    }

### Struct: Immutable

This FDEPL property controls whether the given Franca struct represents a data structure that cannot
be modified after creation. Default value is `false`, i.e. the generated data structure is
modifiable.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            Immutable = true
        }
    }

### Struct, Enumeration, Interface: ExternalType

This FDEPL property controls whether the C++ header file is generated for the given Franca type.
Default value is `null`, i.e. the type is not external and thus a header file is generated. If a
non-empty value is given, no header file is generated, but the given String value is used as a
comma-separated list of paths to pre-existing header files instead. This property has no effect on
generated code for Java or Swift.

For an external type, the name is assumed to match its "external" counterpart in the source file,
and thus is taken verbatim in generated C++ and conversion code (i.e. without any naming convention
being applied to the name). Same "verbatim" logic applies to the names of the child elements of an
external type: fields in a struct, enumerators in an enumeration, various child elements in an
interface.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
        }
    }

### Struct, Enumeration, Interface: ExternalName

This FDEPL property controls whether the C++ fully-qualified name for the given Franca type differs
from the name specified in the FIDL file. Default value is `null`, i.e. the type name is governed by
what is specified in the FIDL file. If a non-empty value is given, then this value is used verbatim
as a fully-qualified name in C++ generated code and in "glue layer" generated code (i.e. JNI and
CBridge). This property has no effect on generated code for Java or Swift.

**Note:** This property is intended for usage in combination with `ExternalType` property (see
above) and thus only applies to types already marked with `ExternalType`.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
            ExternalName = "::external::SomeStruct"
        }
    }

### Struct field, Attribute: ExternalGetter/ExternalSetter

These FDEPL properties control whether the accessor methods are used as a source of data for the
given Franca field. Default value is `null`, i.e. the struct field is used as a data source by the
"glue layer" generated code (i.e. JNI and CBridge). If a non-empty values are given, the given
getter and setter function are used instead. This property has no effect on generated code for
public APIs (i.e. C++, Java, and Swift).

**Note:** The Franca struct which contains the field should be marked with `ExternalType` property
(see above). Both `ExternalGetter` and `ExternalSetter` properties have to be specified at the same
time (or not at all).

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            String exampleField
        }
    }

FDEPL:

    define ExternalTypes for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            ExternalType = "example/ExampleStruct.h"
            exampleField {
                ExternalGetter = "get_example_field"
                ExternalSetter = "set_example_field"
            }
        }
    }

### Attribute: ExternalGetter/ExternalSetter

These FDEPL properties control which accessor methods are used as a source of data for the
given Franca attribute. These properties are valid only if the Franca interface containing the
attribute is marked with `ExternalType` property (see above). These properties are also mandatory in
this case. This property has no effect on generated code for public APIs (i.e. C++, Java, and
Swift).

**Note:** Both `ExternalGetter` and `ExternalSetter` properties have to be specified at the same
time (only `ExternalGetter` for readonly attributes).

FIDL:

    package example

    interface ExampleInterface {
        attribute String exampleAttribute
    }

FDEPL:

    define ExternalTypes for interface example.ExampleInterface
    {
        attribute exampleAttribute {
            ExternalGetter = "get_example_attribute"
            ExternalSetter = "set_example_attribute"
        }
    }

### Struct field: DefaultValue

This FDEPL property controls whether a default value initializer is generated for the given
field in the given Franca struct. Default value is `null`, i.e. no default value initializer is
generated.

**Note:** The type of this property in the FDEPL file is always `String` regardless of the actual
type of the struct field. The given string value is converted to represent a value of the correct
type in the generated code. Special values of "NaN", "Infinity" and "-Infinity" are supported for
Float and Double fields.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            Float floatField
            String stringField
        }
    }

FDEPL:

    define Defaults for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            floatField {
                DefaultValue = "3.14"
            }
            stringField {
                DefaultValue = "some string"
            }
        }
    }

### Struct field: DefaultIsNull

This FDEPL property controls whether the given nullable field in the given Franca struct is
initialized with a language-appropriate `null` value. Default value is `false`, i.e. no default
value initializer is generated (unless otherwise specified with `DefaultValue` property, see above).

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            String stringField
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            stringField {
                Nullable = true
            }
        }
    }

    define Defaults for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            stringField {
                DefaultIsNull = true
            }
        }
    }

### Struct field: DefaultIsEmpty

This FDEPL property controls whether the given field of a collection type or a struct type in the
given Franca struct is initialized with a language-appropriate "empty" value. Default value is
`false`, i.e. no default value initializer is generated (unless otherwise specified with
`DefaultValue` property, see above).

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            String[] stringsField
        }
    }

FDEPL:

    define Defaults for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            stringField {
                DefaultIsEmpty = true
            }
        }
    }

### Struct field, Attribute, Method parameter: Nullable

This FDEPL property controls whether the given element can have a `null` value (`nil` in Swift).
Default value is `false`, i.e. the field is not nullable.

**Note:** In generated Swift code this property controls whether the field has an "optional" type or
not, therefore enforcing nullability at compile time. For Java generated code the nullability is
expressed through a @Nullable annotation, enabling compile time enforcing when used with Kotlin
language. For C++ generated code for Interfaces the nullability is expressed as a documentation comment.

**Note:** The C++ generated code will use `optional` to express nullability for non-Interface types.
Which implementation is used depends on the compiler version: Genium uses `std::optional` if available,
but falls back to a custom implementation of it otherwise. This behavior can be overwritten with defines,
see generated `Optional.h` header.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct exampleStruct {
            Float floatField
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection
    {
        struct exampleStruct {
            structField {
                Nullable = true
            }
        }
    }

### Most elements: Internal

This FDEPL property controls the access modifier of the given element. Default value is `false`,
i.e. by default all elements are generated as `public`. The `true` value corresponds to `internal`
for generated Swift code code and to "package-private" (i.e. empty access modifier) for generated
Java code. This property currently has no effect on generated code for C++.

**Note:** This property can be applied explicitly (by specifying it in the FDEPL file) to any of the
following Franca element types:
* array
* attribute
* enumeration
* interface
* method
* struct
* struct field

**Note:** This property is applied implicitly (automatically) to Franca typedefs, constants and maps
if one of the types referenced by those is itself "internal" (it is not possible to mark these types
explicitly due to FDEPL syntax restrictions).

**Note:** Struct constructors that initialize "internal" fields are also automatically marked as
"internal". This means that the only way to have a public constructor for such struct is to give
each "internal" field an explicit default value (see `DefaultValue` above).

FIDL:

    package example

    interface ExampleInterface {
        struct exampleStruct {
            Float floatField
            String stringField
        }
    }

FDEPL:

    define Visibility for interface example.ExampleInterface {
        Internal = true

        struct exampleStruct {
            Internal = true

            floatField {
                Internal = true
            }
        }
    }

### Attribute: InternalSetter

This FDEPL property controls the access modifier of the given attribute's setter accessor. Default
value is `false`, i.e. by default the setter has the same visibility as the attribute. The `true`
value corresponds to `internal` for generated Swift code code and to "package-private" (i.e. empty
access modifier) for generated Java code. This property currently has no effect on generated code
for C++.

FIDL:

    package example

    interface ExampleInterface {
        attribute String exampleAttribute
    }

FDEPL:

    define Visibility for interface example.ExampleInterface {
        attribute exampleAttribute {
            InternalSetter = true
        }
    }

### Struct: Companion

This FDEPL property controls whether the struct type has methods and/or constants. Default value is
`null`, i.e. by default a struct type does not have any methods or constants generated. A non-empty
value should correspond to a fully-qualified name of a FIDL interface.

**Note:** Any FIDL interface that is a target of a `Companion` property of a FIDL struct is itself
excluded from the code generation. All methods and constants defined in it are attached to the
struct. All other definitions inside the interface are ignored.

**Note:** Non-static methods on a struct are not allowed to modify the underlying data. Consequently
these methods are generated with a `const` qualifier in C++.

**Note:** A method in a `Companion` interface can be marked as `Constructor` (see above). This
provides a custom constructor for the struct type. Please note that this also skips generation of
the all-fields constructor (which is otherwise generated for all structs), thus disabling the
`JavaBuilder` feature (see below) for this struct type.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct ExampleStruct {
        }
    }

    interface ExampleTypeCollection_ExampleStruct_Companion {
        method exampleMethod {
            out {
                Double result
            }
        }
        const Double exampleConstant = 9.81d
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection {
        struct ExampleStruct {
            Companion = "example.ExampleTypeCollection_ExampleStruct_Companion"
        }
    }

### Struct: JavaBuilder

This FDEPL property controls whether a Builder pattern is generated for the struct type in Java.
Default value is `false`, i.e. by default no Builder pattern is generated. This property has no
effect on generated code for C++ or Swift.

**Note:** The Builder initializes unset fields with their explicit defaults if those are provided
(see `DefaultValue`, `DefaultIsNull`, and `DefaultIsEmpty` above). Unset fields without an explicit
default are initialized with zero or `null` according to the field type.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        struct ExampleStruct {
        }
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection {
        struct ExampleStruct {
            JavaBuilder = true
        }
    }

### Array: IsSet

This FDEPL property controls whether the given Franca array type is treated as a set type in the
generated code. Default value is `false`, i.e. by default arrays are treated normally.

**Note:** Only primitive types (i.e. Boolean, String, and numeric types) and enums are supported as
set elements currently. Structs, instances, arrays, and maps are not supported.

FIDL:

    package example

    typeCollection ExampleTypeCollection {
        array ExampleSet of Double
    }

FDEPL:

    define GeniumExtensions for typeCollection example.ExampleTypeCollection {
        array ExampleSet {
            IsSet = true
        }
    }

### Most elements: platform-specific names (CppName, JavaName, SwiftName)

These FDEPL properties controls the platform-specific names for the given element. Default value is
`null`, i.e. by default the name for the element is derived from its FIDL-defined name for all
platforms. The values of these properties are taken as names verbatim (i.e. without any naming
convention being applied to the name).

**Note:** These properties can be applied to any of the following Franca element types:
* array
* enumeration
* enumerator
* interface
* method
* method argument
* struct
* struct field
* type collection
* typedef

**Note:** FIDL attributes have an extended set of properties for platform-specific names:
`CppGetterName`, `CppSetterName`, `JavaGetterName`, `JavaSetterName`, `SwiftName`.

FIDL:

    package example

    interface ExampleInterface {
        struct ExampleStruct {
            String stringField
        }
    }

FDEPL:

    define Names for interface example.ExampleInterface {
        CppName = "SpecialInterface"

        struct ExampleStruct {
            JavaName = "SpecialStruct"

            stringField {
                SwiftName = "SPECIAL_FIELD"
            }
        }
    }

### Method argument: SwiftArgumentLabel

This FDEPL properties controls the Swift argument label of the given element. Default value is
`null`, i.e. by default the argument label is the same as the parameter name and thus no argument
label is generated. The value of this property is taken verbatim (i.e. without any naming convention
being applied to the name).

**Note:** Setting `SwiftArgumentLabel` to "_" leads to argument label being omitted (see
[Swift documentation][swift_omit]).

FIDL:

    package example

    interface ExampleInterface {
        method exampleMethod {
            in {
                String stringArgument
            }
        }
    }

FDEPL:

    define Names for interface example.ExampleInterface {
        method exampleMethod {
            in {
                stringArgument {
                    SwiftArgumentLabel = "niceName"
                }
            }
        }
    }

[franca]: http://franca.github.io/franca/
[userguide]: https://drive.google.com/file/d/0B7JseVbR6jvhMXhNb1VMRWM0Z3M/view?usp=sharing
[swift_omit]: https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID526
